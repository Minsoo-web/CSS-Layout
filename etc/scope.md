<h1 align="center">실행 컨텍스트 Execution Context</h1>

<p align="center">
    <img alt="scope" src="../images/etc/scope/scope_banner.jpg" width="600">
</p>

# Index

- [Scope](#scope)
- [Execution Context](#execution-context)

## Scope

### MDN Says

현재 실행되는 컨텍스트를 말한다. 여기서 컨텍스트는 값과 표현식이 "표현" 되거나 참조될 수 있음을 의미한다.  
만약 변수 또는 다른 표현식이 "해당 스코프" 내에 있지 않다면 사용할 수 없다.
스코프 또한 계층적인 구조를 가지기 때문에 하위 스코프는 상위 스코프에 접근 할 수 있지만 반대는 불가하다.

### before > 전역변수와 지역변수

전역 변수란 JavaScript에서 제일 바깥 범위(함수에 포함되지 않은)에 만들어진 변수를 말합니다.  
JS에서 최상위 객체는 window이므로 window에 저장되는 거라고 생가하시면 됩니다.(브라우저 기준)

```JavaScript
var x = 'Global';

function changeX(){
    var x = 'local'; // 지역변수 선언
    x = 'Changed local Value' // 지역변수 참조
}

changeX();
console.log(x); // 글로벌 변수 참조

```

위의 예에서 changeX 함수 내부의 x는 지역변수를 우선해서 찾기때문에  
지역변수를 수정하고 전역변수는 수정되지 않았습니다.

그 다음 console.log(x) 에서는 참조할 지역변수가 곧 전역변수 x ='Global' 이기 때문에 전역변수를 참조하게 되는 것입니다.

따라서 x를 어느 곳에서 호출했는지에 따라 x라는 변수가 지역변수가 될 수도 있고 전역변수가 될 수도 있게 되는 것입니다.

### 스코프 체인

내부 함수에서는 외부 함수의 변수에 접근이 가능하지만,  
외부 함수는 내부 함수의 변수에 접근할 수 없습니다.

따라서 내부 함수가 자신이 갖고 있지 않은 변수가 호출되었다면  
자신의 지역에서 먼저 찾고(지역변수), 없다면 한 단계 위로 올라가 찾고를 반복하면서 변수의 값을 참조하게 됩니다.

> 그러므로 모든 함수는 전역 변수를 참조할 수 있게되는 것입니다.

이렇게 꼬리를 물고 계속 범위를 넓히면서 찾는 관계를 `스코프 체인`이라고 합니다.

### 정적 스코프, Lexical Scoping

> 동적 스코프(Dynamic Scope)  
> 함수를 어디서 `호출`하였는지에 따라 상위 스코프를 결정하는 것

정적 스코프의 언어는 함수를 어디서 `선언`하였는지에 따라 상위 스코프를 결정하는 언어입니다.

JS는 정적 스코프의 언어이기때문에 스코프가 함수를 호출할 때가 아닌,  
`선언`할 때 생기게 됩니다.

```JavaScript
var origin_name = 'minsoo';
function log(){
    console.log(origin_name); // 이 함수가 선언됨과 동시에 이 변수는 이미 minsoo
}

function wrapper(){
    var origin_name = 'new minsoo';
    log();
}

wrapper();
```

만약 호출이 되면서 스코프 체이닝이 이루어진다면  
(1) log 함수 내 `origin_name` 선언이 없으므로 한단계 위로 올라갑니다.  
(2) wrapper 함수에 `origin_name` 선언이 있으므로 'new minsoo' 라는 값을 참조해서 내려가게 됩니다.

하지만 JS는 선언을 하면서 스코프가 형성이 되는 정적 스코프의 언어이므로  
(1) log() 선언 -> `origin_name` 의 선언을 찾아볼 수 없으므로 한 단계위로 올라갑니다.  
(2) log() 함수의 한단계 위는 전역 객체이므로 'minsoo' 라는 값을 참조해서 내려오게 됩니다.

> 이러한 이유에서 전역변수는 사용을 지양해야합니다.  
> 변수명이 같아 의도하지 않은 전역변수가 참조될 수도 있기 때문입니다.

위와 같은 이슈를 해결하기 위한 방법중 하나가 객체안의 속성으로 선언해서 사용하는 방법이 있습니다.

```JavaScript
var obj = {
    x: 'local',
    y: function(){
        // some Code
    }
}
```

위처럼 선언하게 되면 x라는 변수명이 겹치게 되더라도 x 를 바로 참조하는 것이 아닌 obj.x 로 참조하기 때문에 혼선이 없습니다.  
위와 같은 방법을 **네임스페이스**를 만든다고 표현합니다.  
C++에서 `using namespace std;` 라고 썼던 것 기억하시나요? ~~혼잣말입니다.~~

#### NameSpace 만들기

```JavaScript
var newScope = function () {
    var x = 10;
    var y = function () {
        console.log(x);
    };
    return { y: y };
};

var $$ = newScope();

$$.y(); // 10

```

위와 같이 저만의 `$$` 네임 스페이스를 만들어 봤습니다!  
이렇게 함수 선언을 통해 return 해주고 싶은 값만 결정해서 return 해주면 x 와 같은 변수들은 private한 값들로써 비공개 되는 겁니다.

## Execution Context

실행 컨텍스트는 ECMAScript 스펙에 따르면 **실행 가능한 코드를 형상화하고 구분하는 추상적인 개념** 이라고 정의합니다.  
쉽게 말하자면 **코드들이 실행되기 위한 환경입니다.**

```JavaScript
var name = 'minsoo';

function movie(){
    var title = 'movie1';

    function seeMovie(){
        var time = 'now';
        console.log(name + 'saw the '+ movie ' at ' + time);
    }
}

movie();
```

위와 같은 코드가 있다고 가정합시다.

위 코드를 실행하게 되면 **실행 컨텍스트 스택(EC Stack)**이 생성하게 되고 프로그램(앱, 브라우저 등등)이 종료할때 소멸하게 됩니다.
이 스택이 생성되고 난 뒤 전역 컨텍스트가 생성되어 포함이 됩니다.

현재 실행 중인 컨텍스트에서 이 컨텍스트와 관련 없는 코드(예: 다른 함수)가 실행되면 새로운 컨텍스트가 생성이 됩니다. 이 컨텍스트는 스택에 쌓이게 되고 컨트롤(제어권)을 갖게 됩니다.

함수 실행이 끝나게 되면 해당 함수의 실행 컨텍스트를 파기하고 직전의 실행 컨텍스트에게 컨트롤을 반환합니다.

### 실행 컨텍스트의 3가지 프로퍼티

실행 컨텍스트는 실행 가능한 코드를 형상화하고 구분하는 추상적인 개념이지만, _물리적으로는 객체의 형태를 가지며_, 다음과 같은 규칙을 갖게 됩니다.

- 전역 컨텍스트가 하나 생성된 후, 함수 호출 시마다 컨텍스트가 생깁니다.
- 컨텍스트 생성시 컨텍스트는 _Variable Object, Scope Cahin, this_ 이렇게 3가지 프로퍼티를 소유하게 됩니다.
- 컨텍스트 생성 후 함수가 실행되는데, 사용되는 변수들은 변수 객체 안에서 값을 찾고 없다면 스코프 체인을 따라 올라가며 찾습니다.
- 함수 실행이 마무리 되면 해당 컨텍스트는 사라집니다.

#### Variable Object (VO / 변수 객체)

실행 컨텍스트가 생성되면 자바스크립트 엔진은 실행에 필요한 여러 정보들을 담을 객체를 생성하는데, 이를 `Variable Object` 라고 합니다.

Variable Object 는 아래와 같은 정보들을 담습니다.

- 변수
- 매개변수(parameter)와 인수 정보(arguments)
- 함수 선언 (함수 표현식은 제외)

아까 예시를 든 코드에서 VO를 객체 형식으로 표현하면 다음과 같습니다.

```javascript
'전역 컨텍스트' : {
    VO: {
        name: 'minsoo', // 전역 변수
        movie: Function Object // 전역 함수
    }
}

// 함수 컨텍스트의 경우
// VO는 Activation Object(AO/ 활성 객체)를 가리키며
// 매개변수와 인수들의 정보를 배열의 형태로 담고 있는 arguments object가 추가됩니다.
'movie': {
    VO: {
        arguments: null,
        title: 'movie1', // 지역변수
        seeMovie: Function Object // 내부 함수
    }
}
```

#### Scope Chain (SC)

스코프 체인은 일종의 **리스트**로서 전역 객체와 중첩된 함수의 스코프의 *레퍼런스*를 차례로 저장하고 있는 것입니다.  
다시 말하자면, 스코프 체인은 해당 전역 또는 함수가 참조할 수 있는 변수, 함수 선언등의 정보를 담고 있는 전역 객체 또는 활성 객체의 리스트를 가리킵니다.

> 스코프 체인은 변수를 검색하는 메커니즘입니다.

예를 들어 함수 내의 코드에서 변수를 참조하려 하면 엔진은 스코프 체인의 첫번째 리스트가 가리키는 AO에 접근하여 변수를 검색하게 됩니다.  
검색에 실패하게되면 다음 리스트가 가리키는 AO를 검색하게 됩니다.  
이와 같이 순차적으로 스코프 체인에서 변수를 검색하는데 결국 검색에 실패하면 정의되지 않은 변수에 접근하는 것으로 판단하여 `Reference` 에러를 발생시키게 되는 것입니다.  
스코프 체인은 함수의 built in 프로퍼티인 `[[Scope]]` 로 참조할 수 있습니다.

![scope](../images/etc/scope/scope.png)

#### this

this 프로퍼티에는 this 값이 할당 됩니다.  
this에 할당되는 값은 함수 호출 패턴에 의해 결정됩니다.

### 실행 컨텍스트의 생성 과정

#### 1. 전역 코드에의 진입

프로그램이 실행되면 **실행 컨텍스트 스택**이 생성이 되고 유일한 전역 객체인 **Global Object(GO)**가 생성이 됩니다.  
이 객체의 프로퍼티는 코드의 어떤 곳에서도 접근이 가능하고, 빌트인 객체들인 Mat, Array, String 등과 BOM, DOM 등이 설정되어 있습니다.

전역 객체가 생성된 이후 전역 코드로 컨트롤이 진입하게 되면,  
**전역 실행 컨텍스트(global EC)**가 생성되고 **실행 컨텍스트 스텍 (EC Stack)**에 쌓이게 됩니다.

#### 1.1 스코프 체인의 생성과 초기화

실행 컨텍스트가 생성이 되면 가장 먼저 스코프 체인의 생성과 초기화가 진행됩니다. 이때 스코프 체인은 **전역 객체**의 레퍼런스를 포함하는 *리스트*가 됩니다.

#### 1.2 변수 객체화 실행 (feat. hoisting)

스코프 체인의 생성과 초기화가 종료되면 **Variable Instantiation(변수 객체화)**가 실행됩니다.

> 변수 객체화는 VO에 프로퍼티와 값을 추가하는 것을 의미합니다.

Variable Instantiation(변수 객체화) 는 아래의 순서로 값을 Set 합니다.

> 1. Function Code인 경우 **매개변수(parameter)**가 VO의 프로퍼티로, **인수(argument)**가 값으로 설정됩니다.
> 2. 대상 코드 내의 **함수 선언** 을 대상으로 **함수 명**이 VO의 프로퍼티로 생성된 _함수 객체_ 가 값으로 설정됩니다. (함수 호이스팅)
> 3. 대상 코드 내의 변수 선언을 대상으로 **변수명**이 VO의 프로퍼티로, *undefined*가 값으로 설정됩니다.

따라서 호이스팅은 선언식을 최상단으로 끌어 올리는 것이 아니라는 것을 알 수 있습니다.

변수 객체 (VO)에 함수명을 프로퍼티로 추가하고 즉시 함수 객체가 값에 할당되기 때문에  
함수가 실행되는 순간의 문맥(context)에서 함수가 선언된 위치는 무관하다는 것을 알 수 있습니다.

따라서 함수 표현식을 통해 함수를 정의하게 될 경우에는 호이스팅이 적용되지 않습니다. 표현식의 경우 일반 변수의 방식을 따르기 때문에 **변수명**이 프로퍼티로 **undefined**가 값으로 설정됩니다.

![scope_hoisting](../images/etc/scope/scope_hoisting.png)

## 참고 문헌

[zeroCho님 블로그](https://www.zerocho.com/category/Javascript/post/5740531574288ebc5f2ba97e)
[빵속에꼼팡이님 블로그](https://soungnote.tistory.com/18)
[poiemaweb.com](https://poiemaweb.com/js-execution-context)
